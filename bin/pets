#! /bin/sh
# version 0.6d
#
# debug {0|1|log}
DEBG=0
#
# default paths. do not alter!
RAMD=/dev/shm/pets
PETS=/etc/pets

dbg() { if [ $DEBG = 1 ] ;then printroutine debug: "$@"
	elif [ $DEBG = log ] ;then LOGS=$PETS/log;LOGF=$LOGS/pets.log
		if [ ! -d $LOGS ] || [ ! -r $LOGF ] ;then mkdir $LOGS;touch $LOGF;chmod 0755 $LOGF ;fi
		if [ "$(wc -l $LOGF|awk '{ print $1 }')" -gt 1000 ] ;then
			LOGN="$(find $LOGS -type f -name "pets.log*"|sort|tail -n1|cut -f 3 -d ".")"
			LOGN="${LOGN:-0}";LOGN="$((LOGN+1))"
			mv $LOGF "$LOGF.$LOGN";touch $LOGF;chmod 0755 $LOGF
		fi
		echo "$(date +"%b %d %T")" "$@" >> $LOGF
	fi
}

revroutine() { echo "$@"|awk '{ for (revr=NF; revr>1; revr--) printf("%s ",$revr); print $revr; }' ;}

listroutine() { CAGE=$PETS/cage;LIST=""
	if [ ! "$(command -v lzop)" ] ;then printroutine 15 lzop;exit 1 ;fi
	if [ -n "$TLST" ] ;then TLST="$(find $CAGE -maxdepth 1 -type f -name "$TLST" -not -path "$CAGE/.*" -not -path "* *")"
	else TLST="$(find $CAGE -maxdepth 1 -type f -not -path "$CAGE/.*" -not -path "* *"|sort)"
	fi
	for FILE in $TLST ;do
		ITEM=$(echo "$FILE"|rev|cut -d "/" -f 1|rev)
		dbg list.1 "$FILE,$ITEM"
		if [ -z "$(echo "$ITEM"|tr -d "[:alnum:]")" ] ;then
			if [ -f "$FILE" ] && grep -q ^USED=yes "$FILE" ;then dbg list.2 $RAMD
				if [ ! -d $RAMD ] && ! grep -q ^BOOT=yes "$FILE" ;then
					if [ -t 0 ] ;then dbg list.3 -;LIST="$(echo $LIST $ITEM|sed -e 's/^[ \t]*//')" ;else printroutine 14 "$FILE"	;fi
				else dbg list.4 -;LIST="$(echo $LIST $ITEM|sed -e 's/^[ \t]*//')" ;fi
			fi
		fi
	done
	if [ ! -d $RAMD ] ;then mkdir -p $RAMD ;fi
	LIST="${LIST:-none!}"
	if [ "$1" = "display" ] ;then displayroutine "$1" "$2" ;exit;fi
	if [ "$LIST" != "none!" ] ;then return 0 ;else return 1 ;fi
}

displayroutine() { if [ -n "$2" ] ;then LIST="$2" ;else printroutine 20 ;fi
	if [ "$LIST" != "none!" ] ;then
		for i in $LIST ;do loadpetroutine "$i"
			if chkmountroutine ;then
				if [ "$ENCR" = yes ] ;then USED=$(revroutine $(df -h|grep "$TARG"|head -n1)|cut -f 2- -d " "|rev|cut -f 2- -d " "|rev)
					printroutine 21 "$i" crypto "$TARG" $USED
				elif [ "$TYPE" = tmpfs ] ;then USED=$(revroutine $(df -h|grep "$TARG"|head -n1)|cut -f 2- -d " "|rev|cut -f 2- -d " "|rev)
					printroutine 21 "$i" tmpfs "$TARG" $USED
				elif [ "$TYPE" = ramfs ] ;then SETF=""
					USED=$(du -xsh -B 1M "$TARG"|cut -f1);AVAL=$(echo "$SIZE - $USED"|bc)
					PERC=$(awk 'BEGIN { $perc = "'"$USED"'" / "'"$SIZE"'" ;printf("%.2f", $perc);printf ("%%", $perc) }'|cut -c3-)
					for f in "$AVAL" "$USED" "$SIZE" ;do
						if [ "$f" -gt 999 ] ;then SETF="$SETF $(echo "scale=1; "$f" / 1024" | bc)G"
						else SETF="$SETF ${f}M" ;fi
					done
					printroutine 21 "$i" ramfs "$TARG" "$PERC" $SETF
				fi
			else printroutine 22 "$i"
			fi
		done
		if [ -f "$CAGE/$LIST" ] ;then grep -v '^$\|^#' "$CAGE/$LIST" ;fi
	fi
}

startroutine() { dbg start.1 "$1";TLST="$1"
	if listroutine ;then printroutine 1
		for i in $LIST ;do loadpetroutine "$i"
			if [ "$NAME" ] ;then
				if chkfilesroutine ;then printroutine 2
				elif ! chkmountroutine ;then mountroutine
					if chkmountroutine ;then dbg start.2 "$i,$TARG,$STOR,$NAME"
						if [ ! -d "$STOR" ] ;then mkdir -p "$STOR";chmod 0700 "$STOR";printroutine 10
						else	ARCH=$(find "$STOR" -maxdepth 1 -type f -name "$NAME.PETS.*.tar.lzo" -printf '%T@ %p\n'|sort -k1 -nr|head -n1|awk '{print $2}') >/dev/null 2>&1
							dbg start.3 "$ARCH"
							if [ -r "$ARCH" ] ;then	printroutine 3
								tar --absolute-names --lzop -xf "$ARCH" -C "$TARG" >/dev/null 2>&1 & pidroutine "$!" synchronizing
								printf "\n"
								advancedroutine restart
								printroutine 4
					 		else
								printroutine 10
							fi
							ARCH=""
						fi
					fi
				else printroutine 16
				fi
			fi
		done
	elif [ "$1" ] ;then printroutine 13 "$1"
	else printroutine 20
	fi
}

syncroutine() { TLST="$1"
	if listroutine ;then dbg sync.1 "$LIST"
		for i in $LIST ;do loadpetroutine "$i"
			if [ "$NAME" ] ;then dbg sync.2 "$NAME"
				if chkfilesroutine ;then printroutine 5
					DATE=$(date +"%Hh%Mm%Ss-%m.%d.%Y")
					if [ -z "$KEEP" ] || [ "$KEEP" -eq 0 ] ;then KEEP=1 ;fi
					if [ ! -d "$STOR" ] ;then mkdir -p "$STOR";chmod 0700 "$STOR" ;fi
					KEEP=$((KEEP+1))
					ARCH="$STOR/$NAME.PETS.${DATE}.tar.lzo"
					tar --ignore-failed-read --absolute-names --lzop $TOPT -cf "$ARCH" "$TARG"/ >/dev/null 2>&1 & pidroutine "$!" synchronizing
					printf "\n"
					dbg sync.3 "$STOR,$NAME,$KEEP,$ARCH"
					find "$STOR" -maxdepth 1 -type f -name "$NAME.PETS.*.tar.lzo" -printf '%T@ %p\n'|sort -k1 -nr|tail -n +${KEEP}|xargs rm >/dev/null 2>&1
					ARCH=""
				else printroutine 9 sync
				fi
			fi
		done
	elif [ "$1" ] ;then printroutine 13 "$1"
	else printroutine 20
	fi
}

stoproutine() { TLST="$1"
	if listroutine ;then dbg stop.1 "$LIST"
		LIST=$(revroutine "$LIST")
		for i in $LIST ;do
			dbg stop.2 "$LIST"
			loadpetroutine "$i"
			if [ "$NAME" ] ;then
				PTAH="$RAMD/$NAME"
				dbg stop.3 "$NAME"
				unmountroutine
			fi
		done
	elif [ "$1" ] ;then printroutine 13 "$1"
	else printroutine 20
	fi
}

mountroutine() {
	printroutine 6 "$NAME"
	mkdir -p "$TARG"
	dbg mnt.1 "$NAME,$TARG"
	if [ "$ENCR" = yes ] ;then
		if [ ! "$(command -v mkfs."$FSFS")" ] ;then printroutine 15 mkfs."$FSFS"
		elif [ ! "$(command -v cryptsetup)" ] ;then printroutine 15 cryptsetup
		else
			PTAH="$RAMD"/"$NAME"
			mkdir -p "$PTAH"
			dbg mnt.2 "$NAME,$PTAH"
			mount -t "$TYPE" pets "$PTAH" -o size="${SIZE}"M
			chmod 700 "$PTAH"
			dd if=/dev/urandom of="$PTAH"/"$NAME" bs=1M count="$SIZE" >/dev/null 2>&1 & pidroutine "$!" randomizing
			LOOP=$(losetup -f)
			losetup "$LOOP" "$PTAH/$NAME"
			cryptsetup create -d /dev/urandom $COPT "$NAME" "$LOOP"
			printf "\n\n"
			cryptsetup status "$NAME"
			printf "\n"
			dbg mnt.4 "$LOOP,$PTAH,$NAME,$COPT"
			if [ "$PARI" = yes ] ;then printroutine 17
				badblocks -swt random /dev/mapper/"$NAME" >/dev/null 2>&1 & pidroutine "$!" generating
				printf "\n"
			fi
			dbg mnt.7 "$FOPT,$MOPT,$NAME,$TARG"
			mkfs."$FSFS" $FOPT /dev/mapper/"$NAME" >/dev/null 2>&1
			mount -t "$FSFS" $MOPT /dev/mapper/"$NAME" "$TARG"
		fi
	else
		mount -t "$TYPE" pets "$TARG" -o size="${SIZE}"M $MOPT
		dbg mnt.8 "$TYPE,$TARG,$SIZE,$MOPT"
	fi
	if chkmountroutine ;then dbg mnt.9 "$COWN,$CMOD,$TARG"
		chown "$COWN" "$TARG";chmod "$CMOD" "$TARG"
	fi
}

unmountroutine() {
	if chkmountroutine ;then dbg umnt.2 -;advancedroutine stop "$TARG";umount "$TARG"
		if [ "$ENCR" = yes ] ;then
			LOOP=$(cryptsetup status "$NAME"|grep "device:"|awk '{print $2}')
			dbg umnt.3 "$LOOP"
			if [ -n "$LOOP" ] ;then cryptsetup remove "$NAME"
				if [ -n "cryptsetup status $NAME|grep $LOOP" ] ;then printroutine 7 ;fi
				losetup -d "$LOOP"
				if [ -n "losetup --show $LOOP|grep $PTAH" ] ;then printroutine 8 ;fi
			fi
			UMNT=$(mount|grep "$PTAH "|head -n1|awk '{print $3}')
			dbg umnt.6 "$UMNT,$PTAH"
			if [ "$UMNT" = "$PTAH" ] ;then umount "$PTAH";printroutine 4 ;fi
		else printroutine 4
		fi
	else printroutine 9 stop
	fi
}

killingroutine() { for PROX in $(lsof -w -F p "$1") ;do PIDS="$PIDS $(echo "$PROX"|cut -c2-)" ;done
	for KILL in $(printf '%s\n' "$PIDS"|sort -u) ;do printroutine 19 "$1" "$KILL";kill -9 "$KILL" ;done
}

advancedroutine() {
	case "$1" in
		restart) dbg adv.1 "$1"
			if [ "$MNTC" ] ;then advmntcroutine mount "$MNTC" ;fi
			if [ "$SRVC" ] ;then advsrvcroutine "$1" ;fi ;;
		stop) dbg adv.2 "$1,$2"
			if [ "$SRVC" ] ;then advsrvcroutine "$1" ;fi
			if [ "$(command -v lsof)" ] ;then killingroutine "$2" ;else printroutine 15 lsof ;fi
			if [ "$MNTC" ] ;then advmntcroutine umount "$MNTC" ;fi ;;
	esac
}

scanlvroutine() { pvscan >/dev/null 2>&1;vgscan >/dev/null 2>&1;lvscan >/dev/null 2>&1 ;}

chklvroutine() { if test "${1#/dev/mapper/*-*}" != "$1" ;then return 0 ;else return 1 ;fi ;}

advmntcroutine() { ACTN=mounting;ARGS="$(echo "$@"|cut -f 2- -d " ")"
	if [ "$1" = "umount" ] ;then ACTN=dismounting;ARGS="$(revroutine "$ARGS")" ;fi
	for ITEM in $ARGS ;do
		DEVC=$(echo "$ITEM"|awk -F':' '{ print $1 }')
		DIRC=$(echo "$ITEM"|awk -F':' '{ print $2 }')
		KEYC=$(echo "$ITEM"|awk -F':' '{ print $3 }')

		#detect UUID entry and convert DEVC var
		if echo "$DEVC"|grep -Eq '[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}' ;then UUID=""
			if UUID="$(blkid -t UUID="$DEVC" -o device)" ;then DEVC="$UUID";UUID="" ;fi
		fi

		if [ -b "$DEVC" ] || chklvroutine "$DEVC" ;then

			#if item has a third :token (crypto)
			if [ -n "$KEYC" ] ;then
				if [ ! "$(command -v cryptsetup)" ] ;then printroutine 15 cryptsetup
				else BLKD=$(echo "$DEVC"|rev|cut -d "/" -f 1|rev)

					if [ "$1" = "mount" ] ;then

						#if third :token of item is a file, use it as a key. if hyphon, ask user passphrase
						if [ -f "$KEYC" ] ;then KEYC="-d $KEYC"
						elif [ "$KEYC" = "-" ] ;then KEYC="-y"
						else printroutine 99 "($DEVC) '$KEYC' not found or bad entry" ;exit 1
						fi

						#luksopen, then set devc to crypto dev name
						printroutine 99 "($TARG) luksOpen on '$BLKD': $(cryptsetup -v $KEYC luksOpen $DEVC $BLKD 2>&1)"
						DEVC="/dev/mapper/$BLKD"

						#do scan for pv/vg/lv devs under newly unlocked crypto
						if [ "$(command -v vgchange)" ] ;then scanlvroutine
						else printroutine 99 "($TARG) skipping lvm scan. not installed.."
						fi

						#if second :token of item is a dir, mount dev. if hyphon, skip
						if [ -d "$DIRC" ] ;then printroutine 18 "$ACTN" "$DEVC" to "$DIRC"
							"$1" "$DEVC" "$DIRC";chown "$COWN" "$DIRC"
						elif [ "$DIRC" = "-" ] ;then printroutine 11 "$ACTN" "$DEVC"
						fi

					elif [ "$1" = "umount" ] ;then

						#generate list of potential lv matching /dev/mapper/X-* from args
						for lv in $(echo "${ARGS%% "$DEVC"*}") ;do
							LARG="$(echo $lv|cut -f 1 -d ":")"
							if chklvroutine "$LARG" ;then
								LARG="$(echo $LARG|rev|cut -f 1 -d "/"|cut -f 2 -d "-"|rev)"
								LVMS="$LVMS $LARG"
							fi
						done

						#process list to disable vg individually avoiding conflict with non-PETS/system vg
						if [ -n "$LVMS" ] ;then
							if [ ! "$(command -v vgchange)" ] ;then printroutine 15 lvm2
							else	for vg in $(printf '%s\n' $LVMS|sort -u) ;do
									if [ -d "/dev/$vg" ] ;then
										printroutine 99 "($TARG) $(vgchange -a n $vg 2>&1)"
									fi
								done
							fi
						fi

						#if second :token of item is a dir, unmount dev. if hyphon, skip
						LVMS="";DEVC="/dev/mapper/$BLKD"
						if [ -d "$DIRC" ] ;then	printroutine 18 "$ACTN" "$DEVC" from "$DIRC";"$1" "$DIRC"
						elif [ "$DIRC" = "-" ] ;then printroutine 11 "$ACTN" "$DEVC"
						fi
						printroutine 99 "($TARG) luksClose on '$BLKD': $(cryptsetup -v luksClose $BLKD 2>&1)"
					fi
				fi

			#if item has no third :token
			elif [ -d "$DIRC" ] ;then
				if [ "$1" = "umount" ] ;then printroutine 18 "$ACTN" "$DEVC" from "$DIRC";"$1" "$DEVC"
				elif [ "$1" = "mount" ] ;then

					#when dev is lv initiate vgchange
					if chklvroutine "$DEVC" ;then
						if [ ! "$(command -v vgchange)" ] ;then printroutine 15 lvm2
						else LVVG="$(echo $DEVC|cut -d "-" -f 1|rev|cut -d "/" -f 1|rev)"
							if [ ! -d "/dev/$LVVG" ] ;then printroutine 99 "($TARG) $(vgchange -a y $LVVG 2>&1)" ;fi
						fi
					fi

					printroutine 18 "$ACTN" "$DEVC" to "$DIRC"
					"$1" "$DEVC" "$DIRC";chown "$COWN" "$DIRC"
				fi
			elif [ "$DIRC" = "-" ] ;then printroutine 11 "$ACTN" "$DEVC"
			fi
		else printroutine 99 "($TARG) can not find block device '$DEVC'"
		fi
	done
}

advsrvcroutine() { if [ "$1" = "stop" ] ;then SRVC="$(revroutine "$SRVC")";ACTN=Stopping ;else ACTN=Restarting ;fi
	for ITEM in $SRVC ;do
		INIT=$(echo "$ITEM"|awk -F':' '{ print $2 }');INIT="${INIT:-init}"
		if [ "$INIT" = init ] ;then dbg srvc.1 "$NAME,$SRVC,$ITEM"
			if [ -x /etc/init.d/"$ITEM" ] ;then /etc/init.d/"$ITEM" "$1" ;fi
		else INIT=$(echo "$ITEM"|awk -F':' '{ print $1 }');ITEM=$(echo "$ITEM"|awk -F':' '{ print $2 }')
			dbg srvc.2 "$NAME,$SRVC,$INIT,$ITEM"
			if [ "$INIT" = systemd ] ;then
				printroutine 12 "$ACTN" "$ITEM";systemctl "$1" "$ITEM"
			fi
		fi

	done
}

loadpetroutine() { CONF="$PETS/cage/$1"
	if [ -r "$CONF" ] ;then
		TRGT="$(grep ^TARG= "$CONF"|awk -F"=" '{ print $2 }'|grep "^/")"
		dbg newp.1 "$CONF,$TRGT"
		if  [ -n "$TRGT" ] ;then
			TARG="";TYPE="tmpfs";SIZE="512";COWN="root:root";CMOD="0644";MOPT="";STOR="$PETS"/store
			KEEP="1";TOPT="";ENCR="no";PARI="no";FSFS="no";FOPT="";COPT="";MNTC="";SRVC=""
			. "$CONF";NAME="$1"
			dbg newp.2 "$NAME"
		else NAME="";dbg newp.3 "$1"
		fi
	else printroutine 13 "$1";fi
}

chkfilesroutine() {
	CHK1=$(find $TARG -maxdepth 1|wc -l) >/dev/null 2>&1;dbg chk1.1 "$TARG,$CHK1"
        if [ "$CHK1" -ge 2 ] ;then return 0;dbg chk1.2 "$CHK1";else return 1;dbg chk1.3 "$CHK1"	;fi
}

chkmountroutine() {
	CHK2=$(mount|grep " $TARG "|awk '{print $3}') >/dev/null 2>&1;dbg chk2.1 "$TARG,$CHK2"
	if [ -n "$CHK2" ] ;then return 0;dbg chk2.2 "$CHK2" ;else return 1;dbg chk2.3 "$CHK2" ;fi
}

printroutine() {
        if [ -t 0 ] ;then HG="$(tput setaf 2)-$(tput sgr 0)";HR="$(tput setaf 1)-$(tput sgr 0)"
		NO="[ $(tput setaf 1)no $(tput sgr 0)]";OK="[ $(tput setaf 2)ok $(tput sgr 0)]";HM="[ $(tput setaf 3)?? $(tput sgr 0)]"
		GR="$(tput setaf 2).$(tput sgr 0)";RD="$(tput setaf 1).$(tput sgr 0)"
        else NO="[ no ]";OK="[ ok ]";HM="[ ?? ]";GR=".";RD="." ;fi
        case "$1" in
	        0)	echo "$HM" 'u wot m8 ?? try: pets {list <pet>|start <pet>|stop <pet>|sync <pet>}' ;;
	        1)	echo "$OK" 'Persistent Encrytable Tmpfs Server:' P${GR}E${GR}T${GR}S${GR} ;;
	        2)	echo "$NO" '('$TARG')' 'this path already has a pets things in it'${RD}${RD} ;;
	        3)	echo "$OK" '('$TARG')' 'syncing files: archive -> pet'${GR}${GR} ;;
	        4)	echo "$OK" '('$TARG')' 'completed!'${GR}${GR} ;;
	        5)	echo "$OK" '('$TARG')' 'syncing files: pet -> archive'${GR}${GR} ;;
	        6)	echo "$OK" '('$TARG')' 'mounting ('"$2"') as: '"$TYPE"'. going to work'${GR}${GR} ;;
	        7)	echo "$OK" '('$TARG')' 'removed cryptsetup device:' "${NAME}"${GR}${GR} ;;
	        8)	echo "$OK" '('$TARG')' 'released loop device:' "${LOOP}"${GR}${GR} ;;
	        9)	echo "$NO" '('$TARG')' 'no pets in there to '"$2"'??'${RD}${RD} ;;
	        10)	echo "$NO" '('$TARG')' 'no archives found to sync'${RD}${RD} ;;
		11)	echo "$HM" '('$TARG')' 'skip '"$2"' device: '"$3"'' ;;
		12)	echo "$OK" "$2"' '"$(echo "$3"|cut -d "." -f 1)"' (via systemctl): '"$3"'.' ;;
	        13)	echo "$NO" 'can not find any pets by the name of:' "${2}"${RD}${RD} ;;
	        14)	echo "$NO" '('"$2"') skipping while BOOT does not equal yes.'"$3"'..' ;;
		15)	echo "$NO" '('"$2"') i can not find this binary'${RD}${RD} ;;
		16)	echo "$NO" '('$TARG')' 'looks like this pet is already mounted'${RD}${RD} ;;
		17)	echo "$OK" '('$TARG')' 'using badblocks to create additional parity'${GR}${GR} ;;
		18)	echo "$OK" '('$TARG')' "$2" "$3" "$4" "$5"${GR}${GR} ;;
		19)	echo "$HM" '('"$2"')' 'issuing a kill on pid ('"$3"') '${RD}${RD} ;;
		20)     echo "$OK" 'pets enabled: '"${LIST}"${GR}${GR} ;;
		21)     echo "$OK" '('"$2"') '${HG}' '$3' @ '$4' '${HG}' ('$5'/'$6' free with '$7' used of '$8')'${GR}${GR} ;;
		22)	echo "$NO" '('"$2"') '${HR}' not mounted!' ${RD}${RD} ;;
		99)	echo "$HM" "$(echo "$2"|tr '\n' ' ')" ;;
		*)	echo "$HM" "$@" ;;
	esac
}

pidroutine() { SECS="$(date +%s)";while kill -0 "$1" 2> /dev/null ;do rotating "$2";sleep 1;done ;}

rotating() {
	case $TOGO in
        	1) printf '%s\r'"$HM "'('"$TARG"') \ '${GR}"$1"${GR}${GR}' \ ('$(($(date +%s)-SECS))'s)';TOGO="2";;
        	2) printf '%s\r'"$HM "'('"$TARG"') | '${GR}${GR}"$1"${GR}' | ('$(($(date +%s)-SECS))'s)';TOGO="3";;
        	3) printf '%s\r'"$HM "'('"$TARG"') / '${GR}${GR}${GR}"$1"' / ('$(($(date +%s)-SECS))'s)';TOGO="4";;
        	*) printf '%s\r'"$HM "'('"$TARG"') - '"$1"${GR}${GR}${GR}' - ('$(($(date +%s)-SECS))'s)';TOGO="1";;
	esac
}

case "$1" in
	start)		startroutine "$2";;
	stop)		syncroutine "$2";stoproutine "$2";;
	sync)		syncroutine "$2";;
	list)		listroutine display "$2";;
	*)		if [ ! -n "$2" ] ;then listroutine display ;else printroutine 0 ;fi;exit;;
esac
