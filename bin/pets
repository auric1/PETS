#! /bin/sh
# version 0.7f
#
# debug, for development purposes only. {0|1|log}
DEBG=0
PETS=/etc/pets
RAMD=/dev/shm/pets
dbg() {	case "$DEBG" in
	1)	printroutine debug: "$@" ;;
	log)	LOGS=$PETS/log;LOGF=$LOGS/pets.log
		if [ ! -d $LOGS -o ! -r $LOGF ] ;then mkdir $LOGS;touch $LOGF;chmod 0755 $LOGF ;fi
		if [ "$(wc -l $LOGF|awk '{print $1}')" -gt 1000 ] ;then
			LOGN="$(find $LOGS -type f -name "pets.log*"|sort|tail -n1|cut -f 3 -d ".")"
			LOGN="${LOGN:-0}";LOGN="$((LOGN+1))"
			mv $LOGF "$LOGF.$LOGN";touch $LOGF;chmod 0755 $LOGF
		fi
		echo "$(date +"%b %d %T")" "$@" >> $LOGF
	;;
	esac
}


listroutine() { CAGE="$PETS/cage";LIST=""
	if [ ! "$(command -v lzop)" ] ;then printroutine 15 lzop;exit 1 ;fi

	#get archive filename of supplied pet or form complete list of pet archives
	TLST="$(find $CAGE -maxdepth 1 -type f -name "${TLST:-*}" -not -path "$CAGE/.*" -not -path "* *"|sort)"

	#develop alphanumeric list of pets to operate on
	for file in $TLST ;do ITEM="$(basename $file)"
		if [ -z "$(echo "$ITEM"|tr -d "[:alnum:]")" ] ;then

			#ensure all pet file vars are quoted
			fixpetroutine quotes "$file"

			#and file exists and USED equals yes
			if [ -f "$file" ] && grep -q ^USED=\"yes\" "$file" ;then

				#and if RAMD doesnt exist and BOOT not equal to yes assume system boot
				if [ ! -d "$RAMD" ] && ! grep -q ^BOOT=\"yes\" "$file" ;then

					#but if no terminal then skip, otherwise continue adding
					if [ -t 0 ] ;then LIST="$(echo $LIST $ITEM|sed -e 's/^[ \t]*//')" ;else printroutine 14 "$file" ;fi
				else LIST="$(echo $LIST $ITEM|sed -e 's/^[ \t]*//')"
				fi
			fi
		fi
	done

	#encrypted tmpfs/ramfs mount base and loop device path. set list to none if doesnt exist
	if [ ! -d "$RAMD" ] ;then mkdir -p "$RAMD" ;fi ;LIST="${LIST:-none!}"

	#if given arg to display, pass it and supplied pet to displayroutine
	if [ "$1" = "display" ] ;then displayroutine "$1" "$2" ;exit ;fi

	#give boolean properties to listroutine based on list content
	if [ "$LIST" != "none!" ] ;then return 0 ;else return 1 ;fi
}


displayroutine() {
	#if pet specified, show vars from file, else show enabled list
	if [ "$2" ] ;then LIST="$2"
		if [ -f "$CAGE/$2" ] ;then printf "\n";grep -v '^$\|^#' "$CAGE/$2";printf "\n"
		else printroutine 13 "$2";exit;fi
	else printroutine 20
	fi

	#cycle pets list, if mounted show stats
	if [ "$LIST" != "none!" ] ;then
		for disp in $LIST ;do loadpetroutine "$disp"
			if mountpoint -q $TARG ;then STAT=""

				#encrypted or tmpfs, grab stats from df. use du for ramfs
				if [ $ENCR = yes -o $TYPE = tmpfs ] ;then
					if [ $ENCR = yes ] ;then TYPE="crypt" ;fi
					STAT="$(df -Ph|grep -v "$RAMD"|grep $TARG|head -n1|awk '{print $5,$3,$4,$2}')"
					printroutine 21 "$disp" $TYPE $TARG $STAT
				elif [ $TYPE = ramfs ] ;then
					if [ ! "$(command -v bc)" ] ;then printroutine 15 bc
					else
						#calc available space with du and format percentage
						DUAV="$(du -xsh -B 1M $TARG|cut -f1)";AVAL="$(echo "$SIZE - $DUAV"|bc)"
						PERC="$(printf "%.0f%%" $(echo "scale=1; ${DUAV}*100/${SIZE}"|bc))"

						#replicate human readable suffixes of df before print (M/G)
						for sufx in "$DUAV" "$AVAL" $SIZE ;do
							if [ "$sufx" -gt 999 ] ;then STAT="$STAT $(printf "%.1f" $(echo "scale=2; ${sufx}/1024"|bc))G"
							else STAT="$STAT ${sufx}M" ;fi
						done
						printroutine 21 "$disp" "$TYPE" $TARG "$PERC" $STAT
					fi
				fi

			#if pet isnt mounted
			else printroutine 10 "$disp"
			fi
		done
	fi
}


startroutine() { TLST="$1"

	#if any pets are found enabled, cycle list
	if listroutine ;then printroutine 1
		for pets in $LIST ;do loadpetroutine "$pets"
			if [ "$NAME" ] ;then

				#mount pet only if TARG is empty and if not already mounted
				if [ "$(ls -A $TARG)" ] ;then printroutine 2
				elif ! mountpoint -q $TARG ;then mountroutine

					#on succesfull mount, find latest archive. create STOR if non-existant
					if mountpoint -q $TARG ;then
						if [ ! -d $STOR ] ;then mkdir -p $STOR;chmod 0700 $STOR;printroutine 9 archive extract
						else
							#establish latest archive file of pet. perform extraction
							ARCH=$(find $STOR -maxdepth 1 -type f -name "$NAME.PETS.*.tar.lzo" -printf '%T@ %p\n'|sort -k1 -nr|head -n1|awk '{print $2}') >/dev/null 2>&1
							if [ -r "$ARCH" ] ;then	printroutine 3 archive pet
								tar --absolute-names --lzop -xf "$ARCH" -C $TARG >/dev/null 2>&1 & pidroutine "$!" synchronizing
								printf "\n"

								#if TARG now has contents, service MNTC/SRVC vars.
								if [ "$(ls -A $TARG)" ] ;then advancedroutine restart;printroutine 4 ;fi
					 		else

								#error if no archive found
								printroutine 9 archive extract
							fi
							ARCH=""
						fi
					fi

				#error when start requested but TARG is already mounted
				else printroutine 16
				fi
			fi
		done

	#if pet specified but not found
	elif [ "$1" ] ;then printroutine 13 "$1"

	#when no pets are found enabled
	else printroutine 20
	fi
}


syncroutine() { TLST="$1"

	#if any pets are found enabled then cycle list for archive creation
	if listroutine ;then
		for sync in $LIST ;do loadpetroutine "$sync"
			if [ "$NAME" ] ;then

				#only if TARG contains files. get date and ensure KEEP/STOR are satisfied
				if [ "$(ls -A $TARG)" ] ;then printroutine 3 pet archive
					if [ ! -d $STOR ] ;then mkdir -p $STOR;chmod 0700 $STOR ;fi

					#generate new archive
					DATE="$(date +"%Hh%Mm%Ss-%m.%d.%Y")"
					ARCH="$STOR/$NAME.PETS.${DATE}.tar.lzo"
					TARO="--ignore-failed-read --absolute-names --lzop"
					tar $TARO $TOPT -cf "$ARCH" $TARG/ >/dev/null 2>&1 & pidroutine "$!" synchronizing
					ARCH="";printf "\n"

					#remove all pets beyond desired KEEP by date
					FNDO="-maxdepth 1 -type f -name "$NAME.PETS.*.tar.lzo""
					find $STOR $FNDO -printf '%T@ %p\n'|sort -k1 -nr|tail -n +$((KEEP+1))|xargs rm >/dev/null 2>&1

				#error when no files found in TARG
				else printroutine 9 pet sync
				fi
			fi
		done

	#if pet specified but not found
	elif [ "$1" ] ;then printroutine 13 "$1"

	#when no pets are found enabled
	else printroutine 20
	fi
}


stoproutine() { TLST="$1"

	#if any pets are found enabled, reverse order of list
	if listroutine ;then LIST="$(revroutine "$LIST")"

		#cycle enabled pets list. attempt to unmount each
		for stop in $LIST ;do NAME="";loadpetroutine "$stop"
			if [ "$NAME" ] ;then PTAH="$RAMD/$NAME";unmountroutine ;fi
		done

	#if pet specified but not found
	elif [ "$1" ] ;then printroutine 13 "$1"

	#when no pets are found enabled
	else printroutine 20
	fi
}


mountroutine() { printroutine 6 "$NAME";mkdir -p $TARG

	#if pet is encrypted, check support for fs and dmcrypt
	if [ $ENCR = yes ] ;then
		if [ ! "$(command -v mkfs.$FSFS)" ] ;then printroutine 15 mkfs.$FSFS
		elif [ ! "$(command -v cryptsetup)" ] ;then printroutine 15 cryptsetup
		else

			#use TYPE to set up path for loop device location
			PTAH="$RAMD"/"$NAME";mkdir -p "$PTAH"
			mount -t $TYPE pets "$PTAH" -o size=${SIZE}M
			chmod 700 "$PTAH"

			#creation of loop file
			dd if=/dev/urandom of="$PTAH"/"$NAME" bs=1M count=$SIZE >/dev/null 2>&1 & pidroutine "$!" randomizing

			#get next available loop device and use it for loop file
			LOOP=$(losetup -f);losetup "$LOOP" "$PTAH/$NAME"

			#creation of crypt on loop device, displaying status
			cryptsetup create -d /dev/urandom $COPT "$NAME" "$LOOP"
			printf "\n\n";cryptsetup status "$NAME";printf "\n"

			#use badblocks on crypt device if desired
			if [ $PARI = yes ] ;then printroutine 17
				badblocks -swt random /dev/mapper/"$NAME" >/dev/null 2>&1 & pidroutine "$!" generating
				printf "\n"
			fi

			#format crypt device with intended filesystem, then mount
			mkfs.$FSFS $FOPT /dev/mapper/"$NAME" >/dev/null 2>&1
			mount -t $FSFS $MOPT /dev/mapper/"$NAME" $TARG
		fi
	else

		#perform simple mount
		mount -t $TYPE pets $TARG -o size=${SIZE}M $MOPT
	fi

	#if mount appears successful, modify target permissions
	if mountpoint -q $TARG ;then chown $COWN $TARG;chmod $CMOD $TARG ;fi
}


unmountroutine() {

	#if TARG is mounted, run advanced before unmount
	if mountpoint -q $TARG ;then advancedroutine stop $TARG;umount $TARG

		#if encrypted, get loop device from status and remove crypt device
		if [ $ENCR = "yes" ] ;then
			LOOP="$(cryptsetup status "$NAME"|grep "device:"|awk '{print $2}')"
			if [ -n "$LOOP" ] ;then cryptsetup remove "$NAME"

				#if successful, remove loop device
				if [ -n "cryptsetup status $NAME|grep $LOOP" ] ;then printroutine 7 ;fi
				losetup -d "$LOOP"
				if [ -n "losetup --show $LOOP|grep $PTAH" ] ;then printroutine 8 ;fi
			fi

			#redundant mount check then proceed with umount
			UMNT="$(mount|grep "$PTAH "|head -n1|awk '{print $3}')"
			if [ "$UMNT" = "$PTAH" ] ;then umount "$PTAH";printroutine 4 ;fi

		#if not encrypted, done
		else printroutine 4
		fi

	#error if TARG not mounted
	else printroutine 9 pet stop
	fi
}



advancedroutine() {

	#function controlling order of advanced procedures
	case "$1" in

		restart) #for starting pets, do mounts, then services
			if [ -n "$MNTC" ] ;then advmntcroutine mount "$MNTC" ;fi
			if [ -n "$SRVC" ] ;then advsrvcroutine "$1" ;fi ;;

		stop) #for stopping pets. do services then invoke kills before unmount attempt
			if [ -n "$SRVC" ] ;then advsrvcroutine "$1" ;fi
			if [ "$(command -v lsof)" ] ;then killingroutine "$2" ;else printroutine 15 lsof ;fi
			if [ -n "$MNTC" ] ;then advmntcroutine umount "$MNTC" ;fi ;;
	esac
}


advsrvcroutine() {

	#if stop received, reverse arg order. set ACTN accordingly
	if [ "$1" = "stop" ] ;then SRVC="$(revroutine $SRVC)";ACTN="Stopping" ;else ACTN="Restarting" ;fi

	#cycle list and set unit from token. if no init use rc
	for stok in $SRVC ;do unit="$(echo "$stok"|awk -F':' '{print $2}')";INIT="${unit:-rc}"

		#while init remains and service file is executable, issue command arg
		if [ "$INIT" = rc ] ;then if [ -x /etc/init.d/"$stok" ] ;then /etc/init.d/"$stok" "$1" ;fi

		#if set to systemd, ensure correctness of vars, then manipulate systemctl
		else INIT="$(echo "$stok"|awk -F':' '{print $1}')"

			#use case for future init system options, and to direct action
			case "$INIT" in
				systemd) case $ACTN in
						Restarting) if ! systemctl --quiet is-active "$unit" ;then
								systemctl "$1" "$unit" 2>/dev/null
								if systemctl --quiet is-active "$unit" ;then
									printroutine 12 "$ACTN" "$unit"
								else printroutine 22 "$ACTN" "$INIT" "$unit" started
								fi
							fi
						;;
						Stopping) if systemctl --quiet is-active "$unit" ;then
								systemctl "$1" "$unit" 2>/dev/null
								if ! systemctl --quiet is-active "$unit" ;then
									printroutine 12 "$ACTN" "$unit"
								else printroutine 22 "$ACTN" "$INIT" "$unit" stopped
								fi
							else printroutine 22 "$ACTN" "$INIT" "$unit" started
							fi
						;;
					esac
				;;
			esac
		fi
	done
}


advmntcroutine() { ACTN="mounting";ARGS="$(echo "$@"|cut -f 2- -d " ")"

	#if stop received, reverse args order and set ACTN accordingly. start cycle
	if [ "$1" = "umount" ] ;then ACTN="dismounting";ARGS="$(revroutine "$ARGS")" ;fi

	for mnts in $ARGS ;do

		#develop vars from MNTC args
		DEVC="$(echo "$mnts"|awk -F':' '{print $1}')"
		DIRC="$(echo "$mnts"|awk -F':' '{print $2}')"
		KEYC="$(echo "$mnts"|awk -F':' '{print $3}')"

		#detect UUID entry and convert DEVC var
		if echo "$DEVC"|grep -Eq '[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}' ;then UUID=""
			if UUID="$(blkid -t UUID="$DEVC" -o device)" ;then DEVC="$UUID";UUID="" ;fi
		fi

		#if block device is valid or matches lv naming
		if [ -b "$DEVC" ] || chklvroutine "$DEVC" ;then

			#if item has a third :token (crypto)
			if [ -n "$KEYC" ] ;then
				if [ ! "$(command -v cryptsetup)" ] ;then printroutine 15 cryptsetup
				else BLKD="$(basename $DEVC)"
					case "$1" in
						mount)

							#if third :token of item is a file, use it as a key. if hyphon, ask user passphrase
							if [ -r "$KEYC" ] ;then KEYC="-d $KEYC"
							elif [ "$KEYC" = "-" ] ;then KEYC="-y"
							else printroutine 99 "($DEVC) '$KEYC' not found or bad entry" ;exit 1
							fi

							#luksopen, then set devc to crypto dev name
							printroutine 99 "($TARG) luksOpen on '$BLKD': $(cryptsetup -v $KEYC luksOpen $DEVC $BLKD 2>&1)"
							DEVC="/dev/mapper/$BLKD"

							#do scan for lv devs under newly unlocked crypto
							if [ "$(command -v vgchange)" ] ;then lvscan >/dev/null 2>&1
							else printroutine 99 "($TARG) skipping lvm scan. not installed.."
							fi

							#if second :token of item is a dir, mount dev. if hyphon, skip
							if [ -d "$DIRC" ] ;then printroutine 18 "$ACTN" "$DEVC" to "$DIRC"
								"$1" "$DEVC" "$DIRC";chown $COWN "$DIRC"
							elif [ "$DIRC" = "-" ] ;then printroutine 11 "$ACTN" "$DEVC"
							fi
						;;

						umount)
							#generate list of potential lv matching /dev/mapper/X-* from args
							for lv in $(echo "${ARGS%% "$DEVC"*}") ;do LARG="$(echo $lv|cut -f 1 -d ":")"
								if chklvroutine "$LARG" ;then
									LARG="$(basename $LARG|cut -f 1 -d "-")"
									LVMS="$LVMS $LARG"
								fi
							done

							#process list to disable vg individually avoiding conflict with non-PETS/system vg
							if [ -n "$LVMS" ] ;then
								if [ ! "$(command -v vgchange)" ] ;then printroutine 15 lvm2
								else	for vg in $(printf '%s\n' $LVMS|sort -u) ;do
										if [ -d "/dev/$vg" ] ;then
											printroutine 99 "($TARG) $(vgchange -a n $vg 2>&1)"
										fi
									done
								fi
							fi

							#if second :token of item is a dir, unmount dev. if hyphon, skip
							LVMS="";DEVC="/dev/mapper/$BLKD"
							if [ -d "$DIRC" ] ;then	printroutine 18 "$ACTN" "$DEVC" from "$DIRC";"$1" "$DIRC"
							elif [ "$DIRC" = "-" ] ;then printroutine 11 "$ACTN" "$DEVC"
							fi
							printroutine 99 "($TARG) luksClose on '$BLKD': $(cryptsetup -v luksClose $BLKD 2>&1)"
						;;
					esac
				fi

			#if item has no third :token
			elif [ -d "$DIRC" ] ;then
				case "$1" in
					mount)
						#when dev is lv initiate vgchange
						if chklvroutine "$DEVC" ;then
							if [ ! "$(command -v vgchange)" ] ;then printroutine 15 lvm2
							else LVVG="$(basename $DEVC|cut -f 1 -d "-")"
								if [ ! -d "/dev/$LVVG" ] ;then printroutine 99 "($TARG) $(vgchange -a y $LVVG 2>&1)" ;fi
							fi
						fi
						printroutine 18 "$ACTN" "$DEVC" to "$DIRC"
						"$1" "$DEVC" "$DIRC";chown $COWN "$DIRC"
					;;

					umount)	printroutine 18 "$ACTN" "$DEVC" from "$DIRC";"$1" "$DEVC" ;;
				esac
			elif [ "$DIRC" = "-" ] ;then printroutine 11 "$ACTN" "$DEVC"
			fi
		else printroutine 99 "($TARG) can not find block device '$DEVC'"
		fi
	done
}


loadpetroutine() { CONF="$PETS/cage/$1"
		if fixpetroutine pre "$CONF" ;then

			#set defaults of pet file vars
			TARG="";TYPE="tmpfs";SIZE="512";COWN="root:root";CMOD="0644";MOPT="";STOR="$PETS/store"
			KEEP="1";TOPT="";ENCR="no";PARI="no";FSFS="xfs";FOPT="";COPT="";MNTC="";SRVC="";NAME="$1"

			#include pet file, check vars
			fixpetroutine post "$CONF"

		#error if no pet found
		else printroutine 13 "$1"
	fi
}

fixpetroutine() {
	case "$1" in
		quotes)	#ensure all pet file vars are quoted

			#save in hold buff, remove everything before #, swap with hold buff, remove comment
			EXP1="h;s/[^#]*//1;x;s/#.*//"
			#remove all single and double quotes
			EXP2="s/['\"]//g"
			#insert " after 5th postion every line
			EXP3="s/./&\"/5"
			#insert " and end of every line
			EXP4="s/$/\"/g"
			#reduce any amount of " to a single occurance
			EXP5="s/([\"])+/\"/g"
			#remove leading "
			EXP6="s/^\"//"
			#fix enabled, empty vars with missing quote eg VAR="
			EXP7="s/\=\"$/\=\"\"/g"
			#append newline and hold buff, remove last newline
			EXP8="G;s/(.*)\n/\1/"

			#perform operation
			sed -i -r ''"$EXP1"';'"$EXP2"';'"$EXP3"';'"$EXP4"';'"$EXP5"';'"$EXP6"';'"$EXP7"';'"$EXP8"'' "$2"
		;;

		pre) # rejects loading pet if any of these vars have critical format errors

			#reset failed state var. start read on pet file vars
			PFLD="";BASE="$(basename $CONF)"
			while IFS="=" read pvar valu ;do
				if echo "$pvar"|grep -Eq '^[[:alpha:]]{4}$' ;then valu="$(echo $valu|sed 's/\"//g')"
					case "$pvar" in

						TARG) #no null
							if echo $valu|grep -Eq '\0' ;then PFLD="1"
								printroutine 98 "$(BASE) $pvar invalid setting. no null char allowed"
							fi
						;;

						STOR) #no null
							if echo $valu|grep -Eq '\0' ;then PFLD="1"
								printroutine 98 "($BASE) $pvar invalid setting. no null char allowed"
							fi
						;;

						COWN) #word:word - contain semi
							if ! echo $valu|grep -Eq '^[[:alnum:]]+\:[[:alnum:]]+$' ;then PFLD="1"
								printroutine 98 "($BASE) $pvar invalid setting. must be 'user:group'"
							fi
						;;

						CMOD) #numeric of 3 or 4 chars
							if ! echo $valu|grep -Eq '^[[:digit:]]{3,4}$' ;then PFLD="1"
								printroutine 98 "($BASE) $pvar invalid setting. must be 3 or 4 digits only"
							fi
						;;

						SRVC) # (systemd:)?service ,repeated, match all. iterate for token-specific output
							for vtok in $valu ;do
								if ! echo "$vtok"|grep -Eq '^(systemd\:)?([A-Za-z0-9_.-])+$' ;then PFLD="1"
									printroutine 98 "($BASE) $pvar invalid token: $vtok"
								fi
							done
						;;

						MNTC) # (/dev/path|UUID):(-|/path)(:-|:/path) ,repeated, match all. iterate for token-specific output
							for vtok in $valu ;do
								#match /dev/path|UUID
								MTK1="^(/dev/[0-9a-zA-Z_./\-]+|[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12})"
								#match : and -|/path
								MTK2=":(-|\/[0-9a-zA-Z_./]+)"
								#match optional :-|/path
								MTK3="(\:-|\:[0-9a-zA-Z_./]+)?$"
								if ! echo "$vtok"|grep -Eq "^${MTK1}${MTK2}${MTK3}" ;then PFLD="1"
									printroutine 98 "($BASE) $pvar invalid token: $vtok"
								fi
							done
						;;
					esac
				fi
			done < "$2"

			#get boolean on failed state
			if [ "$PFLD" = "1" ] ;then return 1;else return 0;fi
		;;

		post) #load and attempt to fix minor format errors in pet file variables
			. "$2";PVAR="TYPE SIZE KEEP ENCR PARI TOPT COPT TARG STOR"
			for pfix in $PVAR ;do
				case $pfix in

					TARG) #reduce any amount of / to 1. trailing / not required
						if echo $TARG|grep -Eq '\/\/' ;then
							printroutine 99 "($TARG) $pfix removing multiple slashes. now set to: $TARG"
							TARG="$(echo $TARG|sed -r 's/([\/])+/\//g')"
						fi
						if echo $TARG|grep -Eq '*\/$' ;then TARG="$(echo $TARG|sed 's/\/$//')"
							printroutine 99 "($TARG) $pfix removing trailing slash. now set to: $TARG"
						fi
					;;

					STOR) #trailing / not required
						if echo $STOR|grep -Eq '*\/$' ;then STOR="$(echo $STOR|sed 's/\/$//')"
							printroutine 99 "($TARG) $pfix removing trailing slash. now set to: $STOR"
						fi
					;;

					TYPE) #if not ramfs/tmpfs, use tmpfs
						if ! echo $TYPE|grep -Eq '^([rR][aA][mM]|[tT][mM][pP])[fF][sS]$' ;then TYPE="tmpfs"
							printroutine 99 "($TARG) $pfix must be tmpfs or ramfs. now set to: $TYPE"
						fi
					;;

					SIZE) #if alpha found strip and give warning
						if [ ! -z "$(echo $SIZE|sed 's/[0-9]*//g')" ] ;then SIZE="$(echo $SIZE|sed 's/[^0-9]*//g')"
							printroutine 99 "($TARG) $pfix must not contain anything but numbers. now set to: $SIZE"
						fi
					;;

					KEEP) #if alpha found strip and give warning
						if [ ! -z "$(echo $KEEP|sed 's/[0-9]*//g')" ] ;then KEEP="$(echo $KEEP|sed 's/[^0-9]*//g')"
							printroutine 99 "($TARG) $pfix must not contain anything but numbers. now set to: $KEEP"
						fi
					;;

					ENCR) #if not yes/no, use no
						if ! echo $ENCR|grep -Eq '^([yY][eE][sS]|[nN][oO])$' ;then ENCR="no"
							printroutine 99 "($TARG) $pfix must be yes or no. now set to: no"
						fi
					;;

					PARI) #if not yes/no, use no
						if ! echo $PARI|grep -Eq '^([yY][eE][sS]|[nN][oO])$' ;then PARI="no"
							printroutine 99 "($TARG) $pfix must be yes or no. using: no"
						fi
					;;

					TOPT) #inherent options not required - remove them
						INHT="\-\-ignore\-failed\-read \-\-absolute\-names \-\-lzop"
						for fixn in $INHT ;do
							if echo $TOPT|grep -q $fixn ;then
								printroutine 99 "($TARG) $pfix remove inherent option: '$(echo $fixn|sed 's/\\*//g')'"
								TOPT="$(echo $TOPT|sed -r 's/\"//g;s/'"$fixn"'//g')"
							fi
						done
						INHT=""
					;;

					COPT) #inherent options not required - remove them
						INHT="create \-d \/dev\/urandom"
						for fixn in $INHT ;do
							if echo $COPT|grep $fixn ;then
								printroutine 99 "($TARG) $pfix remove inherent option '$(echo $fixn|sed 's/\\*//g')'"
								COPT="$(echo $COPT|sed -r 's/\"//g;s/'"$fixn"'//g')"
							fi
						done
						INHT=""
					;;
				esac
			done
		;;
	esac
}


#true if arg matches ^/dev/mapper/*-*
chklvroutine() { if expr "$1" : '/dev/mapper/.*-.*' >/dev/null 2>&1 ;then return 0 ;else return 1 ;fi ;}


#reverse order of space-delimited args in a string
revroutine() { echo "$@"|awk '{for (revr=NF; revr>1; revr--) printf("%s ",$revr); print $revr;}' ;}


killingroutine() {

	#generate list of pids in use under supplied target
	for prox in $(lsof -w -F p "$1") ;do PIDS="$PIDS $(echo "$prox"|cut -c2-)" ;done

	#cycle list after duplicates removed, to kill remainders
	for klll in $(printf '%s\n' "$PIDS"|sort -u) ;do printroutine 19 "$1" "$klll";kill -9 "$klll" ;done; sleep 1
}


#rotate while given pid is active pass secs var for timer
pidroutine() { SECS="$(date +%s)";while kill -0 "$1" 2> /dev/null ;do rotating "$2";sleep 1;done ;}


#give spinning timer wheel to functions
rotating() {
	case $TOGO in
		1) printf '%s\r'"$HM "'('$TARG') \ '${GR}"$1"${GR}${GR}' \ ('$(($(date +%s)-SECS))'s)';TOGO="2";;
		2) printf '%s\r'"$HM "'('$TARG') | '${GR}${GR}"$1"${GR}' | ('$(($(date +%s)-SECS))'s)';TOGO="3";;
		3) printf '%s\r'"$HM "'('$TARG') / '${GR}${GR}${GR}"$1"' / ('$(($(date +%s)-SECS))'s)';TOGO="4";;
		*) printf '%s\r'"$HM "'('$TARG') - '"$1"${GR}${GR}${GR}' - ('$(($(date +%s)-SECS))'s)';TOGO="1";;
	esac
}


printroutine() {

	#try to use color
        if [ -t 0 ] ;then HG="$(tput setaf 2)-$(tput sgr 0)";HR="$(tput setaf 1)-$(tput sgr 0)";FS="$(tput setaf 2)/$(tput sgr 0)"
		NO="[ $(tput setaf 1)no $(tput sgr 0)]";OK="[ $(tput setaf 2)ok $(tput sgr 0)]";HM="[ $(tput setaf 3)?? $(tput sgr 0)]"
		GR="$(tput setaf 2).$(tput sgr 0)";RD="$(tput setaf 1).$(tput sgr 0)"
        else NO="[ no ]";OK="[ ok ]";HM="[ ?? ]";GR=".";RD="." ;fi

	#output set.
        case "$1" in
	        0)	echo "$HM" 'u wot m8 ?? try: pets {list <pet>|start <pet>|stop <pet>|sync <pet>}' ;;
	        1)	echo "$OK" 'Persistent Encrytable Tmpfs Server:' P${GR}E${GR}T${GR}S${GR} ;;
	        2)	echo "$NO" '('$TARG') this path already has a pets things in it'${RD}${RD} ;;
	        3)	echo "$OK" '('$TARG') syncing files: '"$2"' -> '"$3"${GR}${GR} ;;
	        4)	echo "$OK" '('$TARG') completed!'${GR}${GR} ;;
	        6)	echo "$OK" '('$TARG') mounting ('"$2"') as: '"$TYPE"'. going to work'${GR}${GR} ;;
	        7)	echo "$OK" '('$TARG') removed cryptsetup device:' "${NAME}"${GR}${GR} ;;
	        8)	echo "$OK" '('$TARG') released loop device:' "${LOOP}"${GR}${GR} ;;
	        9)	echo "$NO" '('$TARG') no '"$2"'s in there to '"$3"'??'${RD}${RD} ;;
		10)	echo "$NO" '('"$2"') '${HR}' not mounted!' ${RD}${RD} ;;
		11)	echo "$HM" '('$TARG') skip '"$2"' device: '"$3"'' ;;
		12)	echo "$OK" "$2"' '"$(echo "$3"|cut -d "." -f 1)"' (via systemctl): '"$3"'.' ;;
	        13)	echo "$NO" 'no valid pets by the name of:' "${2}"${RD}${RD} ;;
	        14)	echo "$NO" '('"$2"') skipping while BOOT does not equal yes.'"$3"'..' ;;
		15)	echo "$NO" '('"$2"') i can not find this binary'${RD}${RD} ;;
		16)	echo "$NO" '('$TARG') looks like this pet is already mounted'${RD}${RD} ;;
		17)	echo "$OK" '('$TARG') using badblocks to create additional parity'${GR}${GR} ;;
		18)	echo "$OK" '('$TARG') '"$2" "$3" "$4" "$5"${GR}${GR} ;;
		19)	echo "$HM" '('"$2"') issuing a kill on pid ('"$3"') '${RD}${RD} ;;
		20)     echo "$OK" 'pets enabled: '"${LIST}"${GR}${GR} ;;
		21)     echo "$OK" '('"$2"') '${HG}' '$3' @ '$4' '${HG}' ('$5''${FS}''$6' used with '$7' free of '$8')'${GR}${GR} ;;
		22)	echo "$NO" "$2"' failed. '"$3"' unit ('"$4"') was not '"$5"${RD}${RD} ;;
		98)	echo "$NO" "$(echo "$2"|tr '\n' ' ')" ;;
		99)	echo "$HM" "$(echo "$2"|tr '\n' ' ')" ;;
		*)	echo "$HM" "$@" ;;
	esac
}


if [ "$3" ] ;then printroutine 0;exit
else	case "$1" in
		start)	startroutine "$2";;
		stop)	syncroutine "$2";stoproutine "$2";;
		sync)	syncroutine "$2";;
		list)	listroutine display "$2";;
		*)	if [ "$2" ] ;then listroutine display ;fi ;printroutine 0;exit ;;
	esac
fi
